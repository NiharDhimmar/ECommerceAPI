# app.py
import datetime
import uuid
import psycopg2
from flask import Flask, render_template, request, jsonify
from psycopg2 import sql

app = Flask(__name__)

# Database connection parameters
DB_NAME = "AgenticAI"
DB_USER = "postgres"
DB_PASSWORD = "eonian"
DB_HOST = "localhost"
DB_PORT = "5433"

def get_db_connection():
    """
    Establishes and returns a new database connection.
    This function will be called for each request needing a DB connection
    to ensure connections are properly managed (opened and closed).
    """
    try:
        conn = psycopg2.connect(
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            port=DB_PORT
        )
        return conn
    except Exception as e:
        print(f"Database connection failed: {e}")
        return None

@app.route('/')
def index():
    """Renders the main HTML page."""
    return render_template('index.html')

@app.route('/api/connect', methods=['GET'])
def connect_db_api():
    """API endpoint to test database connection."""
    conn = get_db_connection()
    if conn:
        conn.close()
        return jsonify({"status": "success", "message": "Connected to database successfully."})
    else:
        return jsonify({"status": "error", "message": "Failed to connect to database."}), 500

@app.route('/api/create_table', methods=['POST'])
def create_table_api():
    """API endpoint to create the users table, admin table, and stored procedures."""
    conn = get_db_connection()
    if not conn:
        return jsonify({"status": "error", "message": "Database connection not available."}), 500
    try:
        with conn.cursor() as cur:
            # Create the users table if it doesn't exist
            cur.execute("""
                CREATE TABLE IF NOT EXISTS users (
                    id SERIAL PRIMARY KEY,
                    name VARCHAR(100),
                    email VARCHAR(100) UNIQUE
                );
            """)
            # Create or replace the upsert_user stored procedure
            cur.execute("""
                CREATE OR REPLACE PROCEDURE upsert_user(
                    p_name VARCHAR,
                    p_email VARCHAR
                )
                LANGUAGE plpgsql
                AS $$
                BEGIN
                    INSERT INTO users (name, email)
                    VALUES (p_name, p_email)
                    ON CONFLICT (email) DO UPDATE
                    SET name = p_name;
                END;
                $$;
            """)

            # Create the Admin table if it doesn't exist
            # "Id" is now SERIAL PRIMARY KEY for auto-incrementing integer IDs
            cur.execute("""
                CREATE TABLE IF NOT EXISTS public."Admin" (
                    "Id" SERIAL PRIMARY KEY,
                    "ClientId" UUID NOT NULL,
                    "UserName" TEXT UNIQUE NOT NULL,
                    "Password" TEXT NOT NULL,
                    "Name" TEXT NOT NULL,
                    "Created" TIMESTAMP WITH TIME ZONE NOT NULL,
                    "Updated" TIMESTAMP WITH TIME ZONE NOT NULL
                );
            """)

            # Create or replace the insert_into_admin stored procedure
            # Removed p_id parameter as Id is auto-generated by SERIAL
            cur.execute("""
                CREATE OR REPLACE PROCEDURE insert_into_admin(
                    p_client_id UUID,
                    p_username TEXT,
                    p_password TEXT,
                    p_name TEXT,
                    p_created TIMESTAMP WITH TIME ZONE,
                    p_updated TIMESTAMP WITH TIME ZONE
                )
                LANGUAGE plpgsql
                AS $$
                BEGIN
                    INSERT INTO public."Admin"(
                        "ClientId", "UserName", "Password", "Name", "Created", "Updated"
                    )
                    VALUES (
                        p_client_id, p_username, p_password, p_name, p_created, p_updated
                    );
                END;
                $$;
            """)

            # Create or replace the update_admin stored procedure
            # p_id parameter is now INTEGER
            cur.execute("""
                CREATE OR REPLACE PROCEDURE update_admin(
                    p_id INTEGER,
                    p_client_id UUID,
                    p_username TEXT,
                    p_password TEXT,
                    p_name TEXT,
                    p_updated TIMESTAMP WITH TIME ZONE
                )
                LANGUAGE plpgsql
                AS $$
                BEGIN
                    UPDATE public."Admin"
                    SET
                        "ClientId" = p_client_id,
                        "UserName" = p_username,
                        "Password" = p_password,
                        "Name" = p_name,
                        "Updated" = p_updated
                    WHERE "Id" = p_id;
                END;
                $$;
            """)

            conn.commit()
        conn.close()
        return jsonify({"status": "success", "message": "Tables ('users', 'Admin') and procedures created/updated successfully."})
    except Exception as e:
        conn.rollback()
        conn.close()
        return jsonify({"status": "error", "message": f"Failed to create tables/procedures: {e}"}), 500

@app.route('/api/insert_sample_data', methods=['POST'])
def insert_sample_data_api():
    """API endpoint to insert sample data into the users table using the stored procedure."""
    conn = get_db_connection()
    if not conn:
        return jsonify({"status": "error", "message": "Database connection not available."}), 500
    try:
        with conn.cursor() as cur:
            # Call the upsert_user stored procedure for sample data
            cur.execute("CALL upsert_user(%s, %s);", ('Alice', 'alice@example.com'))
            cur.execute("CALL upsert_user(%s, %s);", ('Bob', 'bob@example.com'))
            conn.commit()
        conn.close()
        return jsonify({"status": "success", "message": "Sample user data inserted/updated using stored procedure."})
    except Exception as e:
        conn.rollback()
        conn.close()
        return jsonify({"status": "error", "message": f"Failed to insert sample user data: {e}"}), 500

@app.route('/api/insert_user', methods=['POST'])
def insert_user_api():
    """API endpoint to insert/update a new user from form data using the stored procedure."""
    data = request.get_json()
    name = data.get('name')
    email = data.get('email')

    if not name or not email:
        return jsonify({"status": "error", "message": "Name and Email are required."}), 400

    conn = get_db_connection()
    if not conn:
        return jsonify({"status": "error", "message": "Database connection not available."}), 500
    try:
        with conn.cursor() as cur:
            cur.execute("CALL upsert_user(%s, %s);", (name, email))
            conn.commit()
            message = f"User '{name}' ({email}) processed successfully via stored procedure."
        conn.close()
        return jsonify({"status": "success", "message": message})
    except Exception as e:
        conn.rollback()
        conn.close()
        return jsonify({"status": "error", "message": f"Failed to process user via stored procedure: {e}"}), 500

@app.route('/api/fetch_data', methods=['GET'])
def fetch_data_api():
    """API endpoint to fetch all users data."""
    conn = get_db_connection()
    if not conn:
        return jsonify({"status": "error", "message": "Database connection not available."}), 500
    try:
        with conn.cursor() as cur:
            # Assuming 'users' table is what you want to fetch here
            cur.execute("SELECT id, name, email FROM users;")
            rows = cur.fetchall()
            column_names = [desc[0] for desc in cur.description]
            users_data = [dict(zip(column_names, row)) for row in rows]
        conn.close()
        return jsonify({"status": "success", "data": users_data})
    except Exception as e:
        conn.close()
        return jsonify({"status": "error", "message": f"Failed to fetch user data: {e}"}), 500

@app.route('/api/add_admin', methods=['POST'])
def add_admin_api():
    """API endpoint to add a new admin using the insert_into_admin stored procedure."""
    data = request.get_json()
    # Client ID can still be UUID, but Admin Id is now auto-generated by DB
    client_id = uuid.UUID(data.get('client_id')) if data.get('client_id') else uuid.uuid4()
    username = data.get('username')
    password = data.get('password')
    name = data.get('name')
    created = datetime.datetime.now(datetime.timezone.utc)
    updated = datetime.datetime.now(datetime.timezone.utc)

    if not username or not password or not name:
        return jsonify({"status": "error", "message": "Username, Password, and Name are required for admin."}), 400

    conn = get_db_connection()
    if not conn:
        return jsonify({"status": "error", "message": "Database connection not available."}), 500
    try:
        with conn.cursor() as cur:
            # Removed admin_id from parameters as it's auto-generated by the DB
            cur.execute("CALL insert_into_admin(%s, %s, %s, %s, %s, %s);",
                        (str(client_id), username, password, name, created, updated))
            conn.commit()
            message = f"Admin '{username}' added successfully (ID auto-generated)."
        conn.close()
        return jsonify({"status": "success", "message": message})
    except Exception as e:
        conn.rollback()
        conn.close()
        return jsonify({"status": "error", "message": f"Failed to add admin: {e}"}), 500

@app.route('/api/update_admin', methods=['POST'])
def update_admin_api():
    """API endpoint to update an existing admin using the update_admin stored procedure."""
    data = request.get_json()
    admin_id = data.get('id') # ID is required for update, now expected as INTEGER
    client_id = data.get('client_id')
    username = data.get('username')
    password = data.get('password')
    name = data.get('name')
    updated = datetime.datetime.now(datetime.timezone.utc)

    if not admin_id or not client_id or not username or not password or not name:
        return jsonify({"status": "error", "message": "All fields (Id, ClientId, Username, Password, Name) are required for admin update."}), 400

    conn = get_db_connection()
    if not conn:
        return jsonify({"status": "error", "message": "Database connection not available."}), 500
    try:
        # Ensure admin_id is an integer for the stored procedure call
        admin_id_int = int(admin_id)
        client_id_obj = uuid.UUID(client_id) # Client ID remains UUID

        with conn.cursor() as cur:
            # admin_id is passed as integer, client_id as string
            cur.execute("CALL update_admin(%s, %s, %s, %s, %s, %s);",
                        (admin_id_int, str(client_id_obj), username, password, name, updated))
            conn.commit()
            message = f"Admin '{username}' (ID: {admin_id}) updated successfully."
        conn.close()
        return jsonify({"status": "success", "message": message})
    except Exception as e:
        conn.rollback()
        conn.close()
        return jsonify({"status": "error", "message": f"Failed to update admin: {e}"}), 500

@app.route('/api/fetch_admins', methods=['GET'])
def fetch_admins_api():
    """API endpoint to fetch all admin data."""
    conn = get_db_connection()
    if not conn:
        return jsonify({"status": "error", "message": "Database connection not available."}), 500
    try:
        with conn.cursor() as cur:
            cur.execute('SELECT "Id", "ClientId", "UserName", "Password", "Name", "Created", "Updated" FROM public."Admin";')
            rows = cur.fetchall()
            column_names = [desc[0] for desc in cur.description]
            admins_data = []
            for row in rows:
                admin_dict = dict(zip(column_names, row))
                # Id is now an integer, no need to convert to str(UUID)
                if "ClientId" in admin_dict and admin_dict["ClientId"] is not None:
                    admin_dict["ClientId"] = str(admin_dict["ClientId"])
                for key in ["Created", "Updated"]:
                    if admin_dict[key] is not None:
                        admin_dict[key] = admin_dict[key].isoformat()
                admins_data.append(admin_dict)
        conn.close()
        return jsonify({"status": "success", "data": admins_data})
    except Exception as e:
        conn.close()
        return jsonify({"status": "error", "message": f"Failed to fetch admin data: {e}"}), 500

if __name__ == '__main__':
    app.run(debug=True, port=5001)
